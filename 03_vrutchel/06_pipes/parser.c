#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/types.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

/*
 * Примем, что максимальный размер файла, читаемого программой curl может достигать 7 мегабайт.
 * Установим этот предел с помощью макроопределения _MAX_SIZE_INET_FILE_ :
*/

#define _MAX_SIZE_INET_FILE_	(7 * 1024 * 1024)

#define IS_SPACER( X )  ((X)==' '||(X)=='\t'||(X)=='\r'||(X)=='\n')	/* проверка Х на принадлежность к разделителям */

/*
 * Подпрограмма поиска HTML-тэга "А"
 *
 * аргументы вызова:
 * char * s	указатель на буфер, внутри которого ищется тэг
 *
 * возвращает 0 если тэг не найден. В случае обнаружения тэга код возврата равен 1, а s будет указывать на область
 * внутри скобок открывающего тэга.
 */
char *findA(char *s) {
    for( ; *s; s++)
        if(*s == '<') {//Нашли открывающуюся скобку тэга
            char *ts = ++s;//зафиксируем s внутри тэга, а его содержимое проанализируем с помощью ts...
        do {
        while(IS_SPACER( *ts )) ts++;//пропуcтили символы разделители
        if((*ts=='a' || *ts=='A')//слово начинающееся с "а" или "А",
                && IS_SPACER(*(ts+1)))//длина которого составляет один имвол?
            return s;//вернем управление вызывавшей программе... s находится внутри искомого тэга

        while(!(IS_SPACER(*ts))//символы, не являющиеся разделители,
            && *ts!='>' && *ts) ts++;//закрывающими тэг скобками, а также не 0 - пропустим (пропуск остатка слова)

        }while(*ts!='>' && *ts);//повторим всё сначала, пока не достигнем закрывающей скобки тэга

        s = ts;	//тэг закончился... этот тэг нас не интересует... Поищем более подходящий...
    }

  return NULL;
};

/*
 * Подпрограмма чтения URL из тэга "А"
 *
 * аргументы вызова:
 * char *s	указатель на тэг внутри буфера, внутри которого ищется параметр href;
 * char *URL	буфер для возврата вызывающей программе значения параметра href при условии, что URL начинается с http
 *              или https, заканчивается символом-разделителем и не содержит внутри символов "();".
 *
 * Возвращает True в случае успешного формирования URL.
 */
bool getValue(char *URL, char *s) {
    char tStr[PATH_MAX];//буфер ключевых слов...
    int i;

    while(1) {
        while(IS_SPACER(*s)) s++;//найдем начало слова...
        sscanf(s,"%s",tStr);//прочитаем слово из буфера тэга

        for(i=0; i<strlen(tStr); i++) {//пройдемся по всему слову (по всем символам)
            if(tStr[i] =='>' 	//проверим, не вышли ли мы за границу ТЭГА?
                || tStr[i] == 0) //или на границу буфера прочитанного из канала...
                return false;// да вышли... URL не найден
            else if(tStr[i] == '=') {//Cлово закончилось... далее будут параметры...
                tStr[i]=0;//вычеркнем из слова символ '=' и ограничим на этом длину слова...
                break;
                } else
                    tStr[i] = toupper(tStr[i]);//преобразуем символ к верхнему регистру...
        }

        s += strlen(tStr);//подвинем указатель положения во входном потоке за слово...

        if(!strcmp(tStr, "HREF"))//повторим все пока не найдем совпадение с "HREF"
        break;
    }

    while(IS_SPACER(*s)) s++;//пропустим символы разделители...
    if(*s != '=') return false;//если после "HREF" нет '=' - значит обнаружена синтаксическая ошибка вместо URL

    s++;//посмотрим, что там после '='...
    while(IS_SPACER(*s)) s++;//пропустим символы-разделители...
    while(*s == '\"' || *s == '\'') s++;//пропустим символы-ограничители...
    sscanf(s,"%s",tStr);// прочитаем URL из буфера тэга

    if(toupper(tStr[0])!='H'
        || toupper(tStr[1])!='T'
        || toupper(tStr[2])!='T'
        || toupper(tStr[3])!='P')//Если URL не наинается с http значит он не соответствует искомому...
            return false;//прекратим разбор тэга и вернём управление вызывавшей программе...

    for(i=strlen(tStr)-1;//начиная с конца слова (URL)
        tStr[i]=='\"'||tStr[i]=='\''; i--)// символы " и ' заменим на 0 (вычеркнем их)
            tStr[i] = 0;				// и этим очистим URL от символов-ограничителей

    if(strchr(tStr, '(')
        || 	strchr(tStr, ')')
        || 	strchr(tStr, ';'))//В URL не могут содержаться эти символы. Это не URL a Scrypt...
            return false;
    strcpy(URL, tStr);//Запишем в параметр значение URL...
    return true;//Успешное завершение...
};

/*
 *  Оcновная программа ...
 */
int parser() {
    char *env = NULL;//указатель на значение переменной окружения (или NULL, если она не существует)
    FILE *nPipe = NULL;//описатель файла для именованного канала...
    char strBuf[PATH_MAX];//буфер для построчного прочтения именованного канала...
    FILE *f;//описатель файла для пайп-канала с линукс-программой curl

    env = getenv("URLS_SRC");//Прочитаем переменную среды URLS_SRC (должна содержать имя pipe-канала)
    if(env==NULL) {
        fprintf(stderr,"\nEnvironment variable %s is not set\n","URLS_SRC");
        return -1;//Завершение работы...
    }

    if((nPipe = fopen(env,"r"))==NULL) {//Откроем этот pipe-канал
        fprintf(stderr,"\nProblems with opening pipe %s", env);
        return -1;
    }

  /*
   * Прочитаем pipe-канал (fifo-файл) построчно. Отуда ожидается список URL, причем
   * в одной строке содержится только URL и он единственный...
   * Для каждой считанной строки запустим curl в параллельном процессе. При этом, адрес (URL)
   * curl получит в командной строке (это строка прочитанная из nPipe). По умолчанию вывод
   * прораммы curl направлен в стандартный поток вывода stdout. Он средствами системного вызова
   * popen быдет перенаправлен в пайп-канал, с которым у нас связан указатель
   * FILE *f; Если при чтении канала f произошла ошибка (прочитано 0 байт), значит curl запущен
   * неудачно, и обрабатывать по сути нечего, иначе - curl запущен успешно и надо
   * организовать обработку его результатов работы. В случае ошибки имеет смысл запросить у nPipe
   * следующую строку (следующий URL), предварительно не забыв закрыть канал f. Процесс чтения будет
   * длиться, пока функция построчного чтения fgets не вернёт NULL, свидетельствующий о конце
   * данных в потоке...
   *
   *    По заданию "дочерний процесс" должен заниматься разбором деятельности curl. По этому:
   * 1. организуем неименованный пайп канал основного процесса (родительского) с дочерним,
   *    предназначенным для разбора информации, выкачанной программой curl из интернета. Для
   *    этой цели используем системный вызов pipe;
   * 2. С помощью системного вызова fork организуем порождение копии текущего (основного) процесса.
   *    fork родительскому (основному) процессу вернет PID (идентификатор процесса) сына, а сын получит
   *    от fork 0. Путем обычного оператора ветвления "if" его "истинные" и "ложные" группы операторов
   *    программы окажутся в разных процессах!
   * 3. После завершения обработки очередного URL пайп канал с программой curl должен быть закрыт.
   */

    // массив для размещения дескрипторов неименованного пайп. pd[0] - для  чтения, а pd[1] - для записи
    int pd[2];
    char cmdStr[PATH_MAX+7];//буфер, для формирования командной строки запуска curl
    int i;//переменная для нахождения символа конца строки в srtBuf
    char iobuf[_MAX_SIZE_INET_FILE_];//буфер для чтения интернет-файлов из потока curl и передачи их для разбора...
    int size = 0;//переменная для получения количества прочитанных из канала байт

    while(fgets(strBuf, PATH_MAX, nPipe)!=NULL) {//построчное чтение канала nPipe. (strBuf = URL)
        if(pipe(pd)) {//создаем канал связи меджу родителем и потомком
            perror("Error: ");//не удалость создать канал для связи с потомком
            break;
        }

        if(fork()>0) {//дублируем текущий процесс...
      								// PID>0 - Это родительский процесс!!!
        /*
        * Родительский процесс будет передавать сыну результаты работы curl. Дескриптор pd[0] не будет
        * востребован. Закроем его...
        */
            close(pd[0]);

            //Сформируем командную строку для запуска curl...
            strcpy(cmdStr, "curl \"");//cmdStr = curl "
            i = strnlen(strBuf, PATH_MAX) - 1;//Последний символ в srtBuf;
            for(; strBuf[i] == 0 || strBuf[i] == '\n'; i--)//просмотр с конца strBuf до тех пор, пока strBuf[i] незначим...
            strBuf[i] = 0;//вычеркнем незначимые символы 0 и \n

            strcat(cmdStr, strBuf);//cmdStr = curl "URL
            strcat(cmdStr,"\"");//cmdStr = curl "URL"

            memset(iobuf,0,_MAX_SIZE_INET_FILE_);//Очистим буфер перед использованием...

            f = popen(cmdStr, "r");//Запустим команду и откроем канал на чтение результатов...
            size = fread(iobuf, 1, _MAX_SIZE_INET_FILE_, f);//Прочитали size байт из потока curl...

            if(size!=0)//Что то прочитано?
                write( pd[1], iobuf, size);//передадим прочитанное сыну на обработку...

            pclose(f);//закроем поток и повторим всё для другого URL
            close(pd[1]);//отключимся от канала связи с сыном...
        } else {//PID==0 - Это дочерний процесс!!!
            close(pd[1]);

            while(size = read(pd[0],iobuf,_MAX_SIZE_INET_FILE_)) {//прочитаем сообщение отца через канал
        /*
        * Произведём разбор полуеныых данных исходя из предположения, что информация представляет собой текст в формате HTML
        * и в нём содержатся гиперссылки.
        * Алгоритм разбора файла будем использовать такой:
        * Просматриваем буфер iobuf с начала и до конца. При этом ищем конструкцию вида:
        * <\S*[aA]\S+((KEYWORD)\S*=\S*(VALUE))*\S>(RAWHTML)<\S* /\S*[aA]\S*>, где \S - любой символ разделитель; [aA] - символ
        * а или А соответственно; (KEYWORD) - ключевое слово, из числа синтаксически допустимых для параметров тэга А;
        * (VALUE) - значение, для присвоения параметру; (RAWHTML) - неразобранный HTML-текст. * - количественный квантор "0 и более";
        * + - количественный квантор "1 и более"; (Точнее, нас будет интересовать только открывающий тэг... <a href="http...">...)
        * 	Для найденных конструкций ищем KEYWORD = "href" (регистр символов любой). Выводим в stdout VALUE для таких ключей при
        * условии, что VALUE имеет структуру: [(http)(HTTP}][sS]?://(LOGIN:PASSWORD@)?Domain.Name/path/to/file/Filename(?REQUEST)...\S+
        * (т.е. начинается с http или https (регистр любой), заканчитается символом разделителем, не содержит внутри символов "();")
        */

                char URL[PATH_MAX];//буфер для URL
                char *s = iobuf;//указатель на текущую позицию в ходе разбора...
                s[_MAX_SIZE_INET_FILE_-1] = 0;//Для защиты алгоритма от выхода за границу буфера обнулим его последний байт...

                while( (s = findA(s)) != NULL )	{//поищем в буфере тэги "А"...

                    if(getValue(URL, s))//поищем параметр тэга "А" href, возмем его значение, проверим на соответствие и запишем в URL
                        printf("\n%s\n",URL);//выведем найднное в stdout
                    }
                }//цикл чтения родителя...

                close(pd[0]);//закроем канал связи с родителем...
        }
    }

    return 0;
}
